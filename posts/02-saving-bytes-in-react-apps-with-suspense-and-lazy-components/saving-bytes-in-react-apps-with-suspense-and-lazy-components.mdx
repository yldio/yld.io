---
title: Saving Bytes in React Apps with Suspense and Lazy Components
slug: saving-bytes-in-react-apps-with-suspense-and-lazy-components
author: James Wright
---

!["A]("https://cdn-images-1.medium.com/max/986/1*ZpeXvOETtbiSxzW3g4BrYw.png")

A staggered waterfall graph of the downloading of a code-split React app.

I’ve recently been building a client-side router for [React]("https://www.yld.io/speciality/react-js/") that also abstracts the [Suspense API]("https://reactjs.org/docs/code-splitting.html#suspense"); that is, the router will provide particular components for the current path (i.e. window.location.pathname), but will also support Suspenseful components out-of-the-box. Unfortunately, it turns out that such an abstraction is not ideal due to its inflexibility, but I would nonetheless like to demonstrate how one can defer the loading of React components using this new feature.

### The App

!["A]("https://cdn-images-1.medium.com/max/852/1*A2iTe7siTJ6W8vbWCilREw.gif")

Ipsum.io is a React app that renders variations of the [Lorem Ipsum]("https://en.wikipedia.org/wiki/Lorem_ipsum") placeholder text commonly used in design and publishing. Each “page” is a React component:

<Gist id="22520366bd1d6b891ffa6964f8a6404c" />

These page components are mapped to particular paths via a [Router]("https://github.com/jamesseanwright/react-lazy-routes/blob/7f4d8a8af0574f4af6881129fc0dffb91945c9c4/src/routing.tsx#L75") component, which provides its consumer with the page for the current path, accessible via a child [render prop]("https://reactjs.org/docs/render-props.html"):

<Gist id="0231b6f3757ad2a15565a6ba2a8b6f0b" />

For example: if the current path is '/office', then the Page parameter passed to the child render prop will be pages.Office. If said path has no associated component, then the element passed via the notFound prop will be rendered.

The user can navigate between routes using the Link component; this renders a regular anchor element (i.e. <a />), but also updates the Router‘s current page; it’s analogous to the [Link component provided by React Router](\"https://github.com/ReactTraining/react-router/blob/7ccbd7eb7ca603ba164ad75181a48038dd5f4321/packages/react-router-dom/docs/api/Link.md\"):

<Gist id="7edc948ec968ab5508ace95b03238390" />

Note that I won’t be covering my router implementation in this article. It’s your standard [Context](\"https://reactjs.org/docs/context.html\") and [setState](\"https://reactjs.org/docs/hooks-state.html\") affair, which is already covered by many [excellent](\"https://tylermcginnis.com/build-your-own-react-router-v4/\") [resources](\"https://medium.com/@stevenkoch/how-to-build-your-own-react-router-with-new-react-context-api-1647406b9b93\"). However, you are more than welcome to peruse [my approach](\"https://github.com/jamesseanwright/react-lazy-routes/blob/7f4d8a8af0574f4af6881129fc0dffb91945c9c4/src/routing.tsx\") over at the [GitHub repository](\"https://github.com/jamesseanwright/react-lazy-routes\").

### The Problem

!["Without]("https://cdn-images-1.medium.com/max/900/1*3_GukAU3yO2rMpurBgC7nA.gif")

With this unified bundle, we’re forcing the client to download content that may never be rendered. Being able to defer the downloading of these various lipsums until the user navigates to their associated route would reduce initial JavaScript parse times and thus the time it takes for the app [to become interactive](\"https://developers.google.com/web/tools/lighthouse/audits/time-to-interactive\"). What if we could therefore split our app into respective chunks for each path?

!["With]("https://cdn-images-1.medium.com/max/640/1*QCtUUBbSOdz4Lksb2_FkVg.gif")

Code splitting in this fashion is nothing new; [Webpack](\"https://webpack.js.org/guides/code-splitting/#dynamic-imports\") and [Rollup](\"https://rollupjs.org/guide/en/\") have provided this out of the box for a while, and there are already various [component-based strategies for consuming these bundles with React](\"https://tylermcginnis.com/react-router-code-splitting/\"). However, React now provides first-class primitives to defer the loading of components until they’re absolutely needed.

### What is Suspense?

Given the context of this article, it may be tempting to view [Suspense](\"https://reactjs.org/docs/code-splitting.html#suspense\") as a lazy loading mechanism, but this is inaccurate. Rather, it provides a means of… well… _suspending_ the rendering of an element subtree until a particular operation completes, allowing React to render other parts of your app in the meantime; a fallback will be shown until said operation is fulfilled.

<Gist id="84ede86caf0e1d5bc1d9da9fb08c1a01" />

In this example, whenever SomeSuspensefulComponent is suspended, the fallback _node_ (this prop supports both React elements and JavaScript primitives such as strings) is rendered within that Suspense [_boundary_](\"https://twitter.com/dan_abramov/status/1150842009403482113\") (i.e. <React.Suspense />).

It’s even possible to nest Suspense boundaries:

<Gist id="1800acbcc9efc70f8bc46e337786f05f" />

With Suspense, we can declaratively determine _what_ to show in lieu of a particular component when it needs to be deferred.

### _How_ can we Suspend Rendering?

It’s all well and good discussing the concept, but _how_ can we trigger this? Looking into the implementation (as of July 2019) of one of the first-party components that supports Suspense is extremely telling:

<Gist id="36a9c2cdfd4c6316eb3f34ae6986180f" />

Much like an [error boundary](\"https://reactjs.org/docs/error-boundaries.html\") catching an error, Suspense will catch the Promise (thenable) thrown in the pending state and render the fallback until it’s resolved; React handles this by unwinding its internal render stack to the nearest Suspense boundary and then continuing to render the subsequent elements in the tree. Charles Stover’s [fetch-suspense](\"https://github.com/CharlesStover/fetch-suspense\") Hook [throws a](\"https://github.com/CharlesStover/fetch-suspense/blob/master/src/fetch-suspense.ts#L63\") [Promise returned by the fetch API in the same way](\"https://github.com/CharlesStover/fetch-suspense/blob/master/src/fetch-suspense.ts#L63\") to inform Suspense that it should render the fallback.

### Lazy Loading Components with React.lazy

As of the original publication date of this article (July 2019), there is actually only a single component provided by the React team that supports Suspense: [React.lazy](\"https://reactjs.org/docs/code-splitting.html#reactlazy\").

React.lazy takes a function that returns a Promise, which should resolve with a React component. Prior to resolving or rejecting, Suspense can tap into this Promise as demonstrated above to render a fallback:

<Gist id="65ce61e84707b19ac9144ef67b0405a0" />

Given that [dynamic imports](\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#Dynamic*Imports\") return Promises, we can take advantage of the aforementioned, configuration-free code splitting provided by the likes of Webpack and Rollup \_and* load these respective ES Module-compliant bundles only when required.

Following this approach, we can update Ipsum.io to take advantage of lazy routing:

<Gist id="7f4818892e9270bcc4793ec996357d09" />

Notice how we can also render non-Suspenseful components (the initial page rendered via the / path) within a Suspense boundary.

As a result of lazy loading, we’re able to reduce the initial bundle size, avoiding the downloading of unused bytes and reducing our [initial time to interactive](\"https://developers.google.com/web/tools/lighthouse/audits/time-to-interactive\").

!["With]("https://cdn-images-1.medium.com/max/640/1*QCtUUBbSOdz4Lksb2_FkVg.gif")

Given the simplicity of the app, I’ve opted to exclude any metrics, but I hope that you can see the potential benefits this will introduce to much larger and feature-rich single-page apps.

### Summary

Suspending the rendering of various React subtrees is a big win for building slick user experiences, allowing the rest of the parent tree to be processed until certain prerequisite tasks are fulfilled. As Suspense rises in popularity, I’m certain we’ll witness all sorts of exciting and pragmatic usages of this feature, but for now, first-class lazy loading is a strong start.

![]("https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=33e0ea3389b6")

---

[Saving Bytes in React Apps with Suspense and Lazy Components](\"https://medium.com/yld-blog/saving-bytes-in-react-apps-with-suspense-and-lazy-components-33e0ea3389b6\") was originally published in [YLD Blog](\"https://medium.com/yld-blog\") on Medium, where people are continuing the conversation by highlighting and responding to this story.
